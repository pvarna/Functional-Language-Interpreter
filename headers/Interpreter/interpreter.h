/** @file parser.h
 *  @brief A class for interpreting the AST generated by the Parser using the Visitor pattern
 *  
 *  @author Peter Kolev
 */

#pragma once

#include "ASTNode.h"
#include "ASTListNode.h"
#include "ASTUnaryFunctionNode.h"
#include "ASTBinaryFunctionNode.h"
#include "ASTTernaryFunctionNode.h"
#include "ASTUserFunctionNode.h"
#include "literal.h"
#include <unordered_map>
#include <stack>
#include <list>

/**
 * @class Interpreter
 */
class Interpreter
{
private:
    static const double EPS; //!< a const for the double comparison

    std::stack<const Literal*> visitedLiterals; //!< stores the already visited literals
    std::vector<const Literal*> userArguments; //!< stores the user arguments for the user-defined functions
    std::unordered_map<std::string, const ASTNode*> userFunctions; //!< stores the user-defined functions and their definitions

    //! Helper function for deallocating the allocated memory for the literals
    void deallocate();

    //! Helper function for checking if a number is a whole number
    bool isInt(double value);

    //! Helper function for checking if a list in infinite
    bool isInfiniteList(const Literal* list);

    //! Helper function for getting a physical list from a literal
    std::list<double> getList(const Literal* list);

    //! Helper function for making a deep copy of a literal
    const Literal* copy(const Literal* toCopy);

    //! Helper function for getting the value of a number literal
    double getNumber(const Literal* number);

    //! Helper function for checking the equality of two lists
    bool compareLists(const Literal* list1, const Literal* list2);

    //! Helper function for checking the equality of a number and the first element of a list
    bool compareNumberAndList(const Literal* number, const Literal* list);

    //! Helper function for adding a new user-defined function
    void addToUserFunctions(const std::string& name, const ASTNode* definition);

    void read();
    void sqrt(const Literal* argument);
    void head(const Literal* argument);
    void tail(const Literal* argument);
    void length(const Literal* argument);
    void list(const Literal* argument);

    //! FUNCTIONS FOR IMPLEMENTING THE VISITOR PATTERN

    //! Function that determines which node should be visited at the moment
    void visit(const ASTNode* node);

    void visitWholeNumber(const ASTNode* node);
    void visitFractionalNumber(const ASTNode* node);
    void visitUserDefinedList(const ASTListNode* node);
    void visitList(const ASTListNode* node);
    void visitArgument(const ASTNode* node);
    void visitFunction(const ASTNode* node);
    void visitFunctionWithoutArguments(const ASTNode* node);
    void visitUnaryFunction(const ASTUnaryFunctionNode* node);
    void visitBinaryFunction(const ASTBinaryFunctionNode* node);
    void visitIf(const ASTTernaryFunctionNode* node);
    void visitTernaryFunction(const ASTTernaryFunctionNode* node);
    void visitUserFunction(const ASTUserFunctionNode* node);

public:

    //! Default constructor
    Interpreter() = default;

    //! Deleted copy constructor
    Interpreter(const Interpreter& other) = delete;
    
    //! Deleted copy assignment operator
    Interpreter& operator = (const Interpreter& other) = delete;
    
    //! Destructor
    ~Interpreter();

    //! Main function for interpreting the AST
    std::string interpret(const ASTNode* astTree, std::ostream& out);
};